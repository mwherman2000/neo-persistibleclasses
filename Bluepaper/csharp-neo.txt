
ankarenkosergey - Today at 7:14 PM
@mwherman2000 I'm trying to implement cast from c sharp structure to byte array
to be able to store it in blockchain

mwherman2000 - Today at 7:17 PM
@ankarenkosergey One pattern/strategy is to convert each field/value/const to individual byte[] and then Concat() them together...
ankarenkosergey - Today at 7:19 PM
Yes, that's  what I'm doing, I was trying to point to strange behavior
with compiler

mwherman2000 - Today at 7:39 PM
@ankarenkosergey To say it another way, the C#.MS  compiler in Visual Studio doesn't know anything the intruction set that the NEO VM supports ...the MS compiler implements the full C# 6.0 specification and knows how to generate MSIL (MS Intermediate Language) code (DLL assembly files)(edited)
The C#.NEO compiler (neon.exe) only supports a subset of the MSIL patterns generated by the MS compiler.  neon.exe reads MSIL files and transcompiles the logic into NEO AVM byte code script files (.AVM files).

ankarenkosergey - Today at 7:42 PM
thank you
great explanation

mwherman2000 - Today at 7:43 PM
The trick is to understand which MSIL patterns that neon.exe understands and then map that back into the subset of C#.MS (C# 6.0 source statement constructs) that neon.exe supports.  I call this subset of C#.MS: C#.NEO.  I'm trying to document this as part of my dApp submission this week.  Something I call NEO Persistable Classes for C#.NEO. ....more news by the end of the week.

Keep asking the questions so I know what to include in my write-up.

Just my opinion but I don't consider Int32 as a native C#.NEO data type.  You can use it for internal calculations, loop indices, etc. but if you plan to  pass it in/out of your SC or put/get into NEO Storage, I don't consider Int32 a native C#.NEO type.  Same for enums ...although it is easy to coerce both int/Int32/enums to and from BigInteger.  I'm not really an authority ...that's just my experience.   BigIntegers, strings and byte[], IMHO, are the only native C#.NEO data types.

Fortelling a problem you're going to find is some of the NEO Helper extension methods (esp. those used for data type conversion) live in 2 classes in  2 different assemblies/namespaces ...which will cause an error at CS#.MS compile-time because Helper.XYZ() will be an ambiguous reference.  To solve this, I usually remove one the "using <namespace>;" statements my code uses the least and the write a wrapper method that uses a fully-qualified method name or whatever.  You'll understand that I'm saying when this happens in your code.
